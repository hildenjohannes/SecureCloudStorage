<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Encrypt</title>
  </head>
  <body>
    <div id="main"></div>
    <script src="main.js"></script>
    <script src="./lib/forge-master/dist2/forge.js"></script>
    <script>
      var node = document.getElementById('main');
      var app = Elm.Main.embed(node);

      app.ports.encrypt.subscribe(function(msg) {
        var encrypted = encrypt(msg);
        app.ports.encrypted.send(encrypted);
      });

      app.ports.decrypt.subscribe(function(msg) {
        var decrypted = decrypt(msg);
        app.ports.decrypted.send(decrypted);
      });

      app.ports.fileSelected.subscribe(function(id) {
        var node = document.getElementById(id);
        if (node === null) {
          return;
        }

        // If your file upload field allows multiple files, you might
        // want to consider turning this into a `for` loop.
        var file = node.files[0];
        var reader = new FileReader();

        // FileReader API is event based. Once a file is selected
        // it fires events. We hook into the `onload` event for our reader.
        reader.onload = (function(event) {
          var arrayBuffer = reader.result;
          var bytes = new Uint8Array(arrayBuffer);
          var string = new TextDecoder("utf-8").decode(bytes);
          var portData = {
            filename: file.name,
            content: string
          };

          // We call the `fileContentRead` port with the file data
          // which will be sent to our Elm runtime via Subscriptions.
          app.ports.fileRead.send(portData);
        });

        // Connect our FileReader with the file that was selected in our `input` node.
        reader.readAsArrayBuffer(file);
      });

      app.ports.download.subscribe(function(data) {
        var filename = data[0];
        var content = data[1];
        var bytes = new TextEncoder("utf-8").encode(decrypt(content));

        var a = window.document.createElement('a');

        a.href = window.URL.createObjectURL(new Blob([bytes], { type: 'application/octet-stream' }));
        a.download = filename;

        document.body.appendChild(a)
        a.click();
        document.body.removeChild(a)
      });

      var key;
      var iv;

      function encrypt(msg) {
        // generate a random key and IV
        // Note: a key size of 16 bytes will use AES-128, 24 => AES-192, 32 => AES-256
        key = forge.random.getBytesSync(16);
        iv = forge.random.getBytesSync(16);

        /* alternatively, generate a password-based 16-byte key
        var salt = forge.random.getBytesSync(128);
        var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
        */

        // encrypt some bytes using CBC mode
        // (other modes include: ECB, CFB, OFB, CTR, and GCM)
        // Note: CBC and ECB modes use PKCS#7 padding as default
        var cipher = forge.cipher.createCipher('AES-CBC', key);
        cipher.start({iv: iv});
        cipher.update(forge.util.createBuffer(msg));
        cipher.finish();
        var encrypted = cipher.output;
        // transforms to hex
        var encryptedHex = encrypted.toHex();
        return encryptedHex;
      }

      function decrypt(encrypted) {
        // transforms hex(string) into bytes
        var encryptedBytes = forge.util.hexToBytes(encrypted);

        // decrypt some bytes using CBC mode
        // (other modes include: CFB, OFB, CTR, and GCM)
        var decipher = forge.cipher.createDecipher('AES-CBC', key);
        decipher.start({iv: iv});
        decipher.update(forge.util.createBuffer(encryptedBytes));
        decipher.finish();
        var decrypted = decipher.output;
        // transforms to hex
        var decryptedHex = decrypted.toHex()

        // transforms to string?
        return forge.util.hexToBytes(decryptedHex);
      }
    </script>
  </body>
</html>
